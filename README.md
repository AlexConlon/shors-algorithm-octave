# shors-algorithm-classical
Classical simulation of Shor's algorithm for 8-bit integers in Octave

Summary: Main is **Shors_algorithm()** with dependencies **fast_shor_algorithm_procedure()**, **had()**, **multiplicative_remainder()**, **ket()**, and **comp_vect()**.

For the task of implementing Shor’s Algorithm, I wrote two main programs, **Shors_algorithm()** and **fast_shor_algorithm_procedure()**, as well as the helper-programs **had()**, **multiplicative_remainder()**, **ket()**, and **comp_vect()**.

**fast_shor_algorithm_procedure(int = m)** takes an integer **m**, smaller than 256, as input and outputs **s**, a guess of the order of the multiplicative group of integers modulo **m**. It does this by simulating a **21-qubit** system, where the first 13 qubits are initialized in superposition and the rest are in the zero state. Quantum measurements are simluated using Monte Carlo methods. Details of each step are included in the code block as comments. I have also included a comment about Octave’s 1-indexing which needed to be adjusted for in the 13-bit measurement **c** (i.e. **c = c-1**) before guessing **s**. However, the program works with the un-adjusted value of **c** until that step. Similarly, the output for the 8-bit measurement **u** is un-adjusted until the output line. 

**Shors_algorithm(int = m, int = n)** takes an integer **m**, smaller than 256, and a number **n** of desired iterations of the function **fast_shor_algorithm_procedure(m)**. The program populates an **n**-dimensional vector, called **s_array**, with the result **s** from each of the **n** runs of **fast_shor_algorithm_procedure(m)**. It then finds the value of **s** with the most occurrences in **s_array**, and returns a 2-dimensional vector containing values **p_1** and **p_2**, where **p_1 x p_2 = m** and **p_1 + p_2 = m + 1 - s**. I found that inputting **n = 100** has a running time of about 100 seconds, and was able to factor **m = 119, 161, 187, 203, 209, 217, 247, 253**. The inputs **m = 133** and **m = 221** were being stubborn, returning non-integers as factors. I thought this might be because I needed more iterations of **fast_shor_algorithm_procedure(m)** to return their factors. However, I later ran **Shors_algorithm(m, n)** on both **m = 133** and **m = 221** for **n = 1000** and the outputs were equal to that of **n = 100**. This lead me to believe that the strategy for guessing **s** was the culprit. However, I ran through each value above for **m** again, and in this round my program managed to return the integer factors for **m = 221**, but still didn’t manage to return factors of **m = 133**, and for the first time, failed to provide the factors for **m = 247**. Since this is a probabilistic procedure, I imagine one could keep running the code **Shors_algorithm(133, 100)** until it returned two integers.

**had(array = q)** takes a state **q** of any size and applies the appropriately sized Hadamard gate to state **q**. e.g. if **q** is a **d-qubit** state, then **had(q)** applies the **dxd** Hadamard gate to **q**. It was necessary to write this function because Octave's Hadamard function does not support the size I needed to factor an 8-bit number **m**.

**multiplicative_remainder(int = m)**, which takes integer **m** as input and returns a random element **t** of the multiplicative group of integers modulo **m**.

**ket(str = e)** takes a d-element string of 1’s and 0’s **e**, and returns the corresponding 2^d-dimensional computational basis vector.

**compt_vect(int = 0 or 1)** returns the appropriate 2-dimensional computational basis vector given the input 0 or 1.
