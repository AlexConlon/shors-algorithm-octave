# shors-algorithm-classical
Classical simulation of Shor's algorithm in Octave

Summary: Main is **Shors_algorithm()** with dependencies **fast_shor_algorithm_procedure()**, **had()**, **multiplicative_remainder()**, **ket()**, and **comp_vect()**.

For the task of implementing Shor’s Algorithm, I wrote two main programs, **Shors_algorithm()** and **fast_shor_algorithm_procedure()**, as well as the helper-programs **had()**, **multiplicative_remainder()**, **ket()**, and **comp_vect()**.

**fast_shor_algorithm_procedure(m)** takes an integer **m**, smaller than 256, as input and outputs **s**, a guess of the order of the multiplicative group of integers modulo **m**. It does this by simulating a **21-qubit** system, where the first 13 qubits are initialized in superposition and the rest are in the zero state. Quantum measurements are simluated using Monte Carlo methods. Details of each step are included in the code block as comments. I have also included a comment about Octave’s 1-indexing which needed to be adjusted for in the 13-bit measurement **c** (i.e. **c = c-1**) before guessing **s**. However, the program works with the un-adjusted value of **c** until that step. Similarly, the output for the 8-bit measurement **u** is un-adjusted until the output line. 

**Shors_algorithm(m, n)** takes an integer **m**, smaller than 256, and a number **n** of desired repetitions of the function **fast_shor_algorithm_procedure()**. The program populates an **n**-dimensional vector, called **s_array**, with the result **s** from each of the **n** runs of **fast_shor_algorithm_procedure()**. It then finds the value of **s** with the most occurrences in **s_array**, and returns a 2-dimensional vector containing values **p_1** and **p_2**, where **p_1 x p_2 = m** and **p_1 + p_2 = m + 1 - s**. I found that inputting **n = 100** has a running time of about 100 seconds, and was able to factor **m = 119, 161, 187, 203, 209, 217, 247, 253**. The inputs **m = 133** and **m = 221** were being stubborn, returning non-integers as factors. I thought this might be because I needed more iterations of **fast_shor_algorithm_procedure()** to return their factors. However, I later ran **Shors_algorithm()** on both **m = 133** and **m = 221** for **n = 1000** and the outputs were equal to that of **n = 100**. This lead me to believe that the strategy for guessing **s** was the culprit. However, I ran through each value above for **m** again, and in this round my program managed to return the integer factors for **m = 221**, but still didn’t manage to return factors of **m = 133**, and for the first time, failed to provide the factors for **m = 247**. Since this is a probabilistic procedure, I imagine one could keep running the code **Shors_algorithm(133, 100)** until it returned two integers.
